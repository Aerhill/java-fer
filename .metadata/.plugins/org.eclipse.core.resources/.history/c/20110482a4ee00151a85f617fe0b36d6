package hr.fer.zemris.java.tecaj.hw2;

/**
 * Class ComplexNumber which represents an unmodifiable complex number. Each
 * method which performs some kind of modification returns a new instance which
 * represents modified number.
 * 
 * @author Ante Spajic
 *
 */
public class ComplexNumber {

    private double real;
    private double imaginary;

    /**
     * 
     * @param realPart
     * @param imaginaryPart
     */
    public ComplexNumber(double realPart, double imaginaryPart) {
	this.real = realPart;
	this.imaginary = imaginaryPart;
    }

    /**
     * 
     * @param real
     * @return
     */
    public static ComplexNumber fromReal(double real) {
	return new ComplexNumber(real, 0.0);
    }

    /**
     * 
     * @param imaginary
     * @return
     */
    public static ComplexNumber fromImaginary(double imaginary) {
	return new ComplexNumber(0.0, imaginary);
    }

    /**
     * 
     * @param magnitude
     * @param angle
     * @return
     */
    public static ComplexNumber fromMagnitudeAndAngle(double magnitude,
	    double angle) {
	return new ComplexNumber(magnitude * Math.cos(angle), magnitude
		* Math.sin(angle));
    }

    /**
     * Parses the <code>String</code> as a <code>ComplexNumber</code> of type
     * x+yi.
     * 
     * @param s
     *            the input complex number as string
     * @return a <code>ComplexNumber</code> which is represented by the string.
     */
    public static ComplexNumber parse(String s) {
	s = s.replaceAll(" ", "");
	ComplexNumber parsed = null;
	if (s.contains(String.valueOf("+"))
		|| (s.contains(String.valueOf("-")) && s.lastIndexOf('-') > 0)) {
	    String re = "";
	    String im = "";
	    s = s.replaceAll("i", "");
	    if (s.indexOf('+') > 0) {
		re = s.substring(0, s.indexOf('+'));
		im = s.substring(s.indexOf('+') + 1, s.length());
		parsed = new ComplexNumber(Double.parseDouble(re),
			Double.parseDouble(im));
	    } else if (s.lastIndexOf('-') > 0) {
		re = s.substring(0, s.lastIndexOf('-'));
		im = s.substring(s.lastIndexOf('-') + 1, s.length());
		parsed = new ComplexNumber(Double.parseDouble(re),
			-Double.parseDouble(im));
	    }
	} else {
	    if (s.endsWith("i") || s.endsWith("I")) {
		s = s.replaceAll("i", "");
		parsed = fromImaginary(Double.parseDouble(s));
	    } else {
		parsed = fromReal(Double.parseDouble(s));
	    }
	}
	return parsed;
    }

    /**
     * Getter for real part of the complex number.
     * 
     * @return Real part of this complex number.
     */
    public double getReal() {
	return real;
    }

    /**
     * Getter for imaginary part of the complex number.
     * 
     * @return Imaginary part of this complex number.
     */
    public double getImaginary() {
	return imaginary;
    }

    /**
     * Returns the magnitude of this complex number. Magnitude is used in
     * trigonometric form of complex number.
     * 
     * @return Magnitude(z) of this complex number.
     */
    public double getMagnitude() {
	return Math.sqrt(real * real + imaginary * imaginary);
    }

    /**
     * Returns the angle of this complex number. Angle is used in trigonometric
     * form of complex number.
     * 
     * @return Angle(phi) of this complex number.
     */
    public double getAngle() {
	return Math.atan2(imaginary, real);
    }

    /**
     * 
     * @param c
     * @return
     */
    public ComplexNumber add(ComplexNumber c) {
	double real = this.real + c.real;
	double imag = this.imaginary + c.imaginary;
	return new ComplexNumber(real, imag);
    }

    /**
     * 
     * @param c
     * @return
     */
    public ComplexNumber sub(ComplexNumber c) {
	double real = this.real - c.real;
	double imag = this.imaginary - c.imaginary;
	return new ComplexNumber(real, imag);
    }

    /**
     * 
     * @param c
     * @return
     */
    public ComplexNumber mul(ComplexNumber c) {
	double real = this.real * c.real - this.imaginary * c.imaginary;
	double imag = this.real * c.imaginary + this.imaginary * c.real;
	return new ComplexNumber(real, imag);
    }

    /**
     * 
     * @param c
     * @return
     */
    public ComplexNumber div(ComplexNumber c) {
	if (c == null) {
	    throw new NullPointerException("Argument cannot be null");
	}
	double a = c.getReal();
	double b = c.getImaginary();
	if (a == 0.0 && b == 0.0) {
	    throw new IllegalArgumentException("Cannot divide by 0");
	}
	if (Math.abs(a) < Math.abs(b)) {
	    double q = a / b;
	    double denominator = a * q + b;
	    return new ComplexNumber((real * q + imaginary) / denominator,
		    (imaginary * q - real) / denominator);
	} else {
	    double q = b / a;
	    double denominator = b * q + a;
	    return new ComplexNumber((imaginary * q + real) / denominator,
		    (imaginary - real * q) / denominator);
	}
    }

    /**
     * Calculates the <code>ComplexNumber</code> to the passed integer power.
     * 
     * @param n
     *            The power we wish to calculate.
     * @return a <code>ComplexNumber</code> which is (z)^power
     */
    public ComplexNumber power(int n) {
	if (n < 0) {
	    throw new IllegalArgumentException(
		    "Power must be greater or equal to 0");
	}
	double magnitude = Math.pow(getMagnitude(), n);
	double angle = getAngle() * n;
	return fromMagnitudeAndAngle(magnitude, angle);
    }

    /**
     * 
     * @param n
     * @return
     */
    public ComplexNumber[] root(int n) {
	if (n <= 0) {
	    throw new IllegalArgumentException(
		    "You requested a negative or 0 root. Root must be positive");
	}
	double rootAngle = getAngle() / n;
	double rootMagnitude = Math.pow(getMagnitude(), 1. / n);
	ComplexNumber[] roots = new ComplexNumber[n];
	for (int i = 0; i < n; i++) {
	    roots[i] = fromMagnitudeAndAngle(rootMagnitude, rootAngle);
	    rootAngle += 2 * Math.PI / n;
	}
	return roots;
    }

    /**
     * 
     */
    @Override
    public String toString() {
	if (imaginary == 0)
	    return real + "";
	if (real == 0)
	    return imaginary + "i";
	if (imaginary < 0)
	    return real + " - " + (-imaginary) + "i";
	return real + " + " + imaginary + "i";
    }

}

package hr.fer.zemris.java.custom.collections;

/**
 * Resizable-array implementation of the Collection. Implements all optional
 * collection operations, and permits all elements, including null. This class
 * provides methods to manipulate the size of the array that is used internally
 * to store the list.
 * 
 * The size, isEmpty, get, run in constant time. The add operation runs in
 * amortized constant time, that is, adding n elements requires O(n) time. All
 * of the other operations run in linear time (roughly speaking). The constant
 * factor is low compared to that for the LinkedList implementation.
 * 
 * @author Ante Spajic
 *
 */
public class ArrayIndexedCollection extends Collection {

    /**
     * Default initial capacity.
     */
    private static final int DEFAULT_CAPACITY = 16;
    
    /**
     * The size of the ArrayList (the number of elements it contains).
     */
    private int size;
    private int capacity;
    
    /**
     * The array buffer into which the elements of the ArrayList are stored.
     * The capacity of the ArrayList is the length of this array buffer.
     */
    private Object[] elements;

    public ArrayIndexedCollection() {
	this(DEFAULT_CAPACITY);
    }

    public ArrayIndexedCollection(int initialCapacity) {
	if (initialCapacity < 1) {
	    throw new IllegalArgumentException();
	}
	this.size = 0;
	this.capacity = initialCapacity;
	this.elements = new Object[capacity];
    }

    public ArrayIndexedCollection(Collection other) {
	this();
	addAll(other);
    }

    public ArrayIndexedCollection(Collection other, int initialCapacity) {
	this(initialCapacity);
	addAll(other);
    }

    /*
     * (non-Javadoc)
     * 
     * @see hr.fer.zemris.java.custom.collections.Collection#isEmpty()
     */
    @Override
    public boolean isEmpty() {
	return size == 0;
    }

    /*
     * (non-Javadoc)
     * 
     * @see hr.fer.zemris.java.custom.collections.Collection#size()
     */
    @Override
    public int size() {
	return size;
    }

    /*
     * (non-Javadoc)
     * 
     * @see
     * hr.fer.zemris.java.custom.collections.Collection#add(java.lang.Object)
     */
    @Override
    public void add(Object value) {
	if (value == null) {
	    throw new IllegalArgumentException();
	}
	if (size == capacity) {
	    elements = resize(elements);
	}
	elements[size++] = value;

    }

    /**
     * Helper method used to double the capacity of an array when attempted to
     * add an element after the capacity has been exceeded
     * 
     * @param elements
     *            Array of elements that needs its capacity doubled
     * @return Resized array of elements
     */
    private Object[] resize(Object[] elements) {
	capacity *= 2;
	Object[] resized = new Object[capacity];
	for (int i = 0; i < elements.length; i++) {
	    resized[i] = elements[i];
	}
	return resized;
    }

    /*
     * (non-Javadoc)
     * 
     * @see
     * hr.fer.zemris.java.custom.collections.Collection#contains(java.lang.Object
     * )
     */
    @Override
    public boolean contains(Object value) {
	return indexOf(value) != -1;
    }

    /*
     * (non-Javadoc)
     * 
     * @see
     * hr.fer.zemris.java.custom.collections.Collection#remove(java.lang.Object)
     */
    @Override
    public boolean remove(Object value) {
	if (!contains(value))
	    return false;
	for (int i = indexOf(value); i < elements.length - 1; i++) {
	    elements[i] = elements[i + 1];
	}
	size--;
	return true;
    }

    /*
     * (non-Javadoc)
     * 
     * @see hr.fer.zemris.java.custom.collections.Collection#toArray()
     */
    @Override
    public Object[] toArray() {
	Object[] povratni = new Object[size];
	int j = 0;
	for (int i = 0; i < elements.length; i++) {
	    if (elements[i] != null) {
		povratni[j++] = elements[i];
	    }
	}
	return povratni;
    }

    /*
     * (non-Javadoc)
     * 
     * @see
     * hr.fer.zemris.java.custom.collections.Collection#forEach(hr.fer.zemris
     * .java.custom.collections.Processor)
     */
    @Override
    public void forEach(Processor processor) {
	for (int i = 0; i < elements.length; i++) {
	    if (elements[i] != null) {
		processor.process(elements[i]);
	    }
	}
    }

    /*
     * (non-Javadoc)
     * 
     * @see
     * hr.fer.zemris.java.custom.collections.Collection#addAll(hr.fer.zemris
     * .java.custom.collections.Collection)
     */
    @Override
    public void addAll(Collection other) {
	super.addAll(other);
    }

    /*
     * (non-Javadoc)
     * 
     * @see hr.fer.zemris.java.custom.collections.Collection#clear()
     */
    @Override
    public void clear() {
	for (int i = 0; i < elements.length; i++)
	    elements[i] = null;

	size = 0;
    }

    public Object get(int index) {
	if (index < 0 || index >= size) {
	    throw new IndexOutOfBoundsException();
	}
	return elements[index];
    }

    public void insert(Object value, int position) {
	if (value == null)
	    throw new IllegalArgumentException();
	if (position < 0 || position >= size)
	    throw new IndexOutOfBoundsException();
	if (++size >= capacity) {
	    elements = resize(elements);
	}
	for (int i = position; i < elements.length; i++) {
	    elements[i + 1] = elements[i];
	}
	elements[position] = value;
    }

    public int indexOf(Object value) {
	if (value == null) {
	    for (int i = 0; i < size; i++)
		if (elements[i] == null)
		    return i;
	} else {
	    for (int i = 0; i < size; i++)
		if (value.equals(elements[i]))
		    return i;
	}
	return -1;
    }

}

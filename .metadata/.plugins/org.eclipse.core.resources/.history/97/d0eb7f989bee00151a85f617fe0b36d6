package hr.fer.zemris.java.tecaj.hw2;

/**
 * Class ComplexNumber which represents an unmodifiable complex number. Each
 * method which performs some kind of modification returns a new instance which
 * represents modified number.
 * 
 * @author Ante Spajic
 *
 */
public class ComplexNumber {

    private double real;
    private double imaginary;

    /**
     * 
     * @param realPart
     * @param imaginaryPart
     */
    public ComplexNumber(double realPart, double imaginaryPart) {
	this.real = realPart;
	this.imaginary = imaginaryPart;
    }

    /**
     * 
     * @param real
     * @return
     */
    public static ComplexNumber fromReal(double real) {
	return new ComplexNumber(real, 0.0);
    }

    /**
     * 
     * @param imaginary
     * @return
     */
    public static ComplexNumber fromImaginary(double imaginary) {
	return new ComplexNumber(0.0, imaginary);
    }

    /**
     * 
     * @param magnitude
     * @param angle
     * @return
     */
    public static ComplexNumber fromMagnitudeAndAngle(double magnitude,
	    double angle) {
	return new ComplexNumber(magnitude*Math.cos(angle),magnitude*Math.sin(angle));
    }

    /**
     * 
     * @param s
     * @return
     */
    public static ComplexNumber parse(String s) {
	return null;
    }

    /**
     * 
     * @return
     */
    public double getReal() {
	return real;
    }

    /**
     * 
     * @return
     */
    public double getImaginary() {
	return imaginary;
    }

    /**
     * 
     * @return
     */
    public double getMagnitude() {
	return Math.sqrt(real * real + imaginary * imaginary);
    }

    /**
     * 
     * @return
     */
    public double getAngle() {
	return Math.atan2(imaginary, real);
    }

    /**
     * 
     * @param c
     * @return
     */
    public ComplexNumber add(ComplexNumber c) {
	double real = this.real + c.real;
	double imag = this.imaginary + c.imaginary;
	return new ComplexNumber(real, imag);
    }

    /**
     * 
     * @param c
     * @return
     */
    public ComplexNumber sub(ComplexNumber c) {
	double real = this.real - c.real;
	double imag = this.imaginary - c.imaginary;
	return new ComplexNumber(real, imag);
    }

    /**
     * 
     * @param c
     * @return
     */
    public ComplexNumber mul(ComplexNumber c) {
	double real = this.real * c.real - this.imaginary * c.imaginary;
	double imag = this.real * c.imaginary + this.imaginary * c.real;
	return new ComplexNumber(real, imag);
    }

    /**
     * 
     * @param c
     * @return
     */
    public ComplexNumber div(ComplexNumber c) {
	if (c == null) {
	    throw new NullPointerException("Argument cannot be null");
	}
	double a = c.getReal();
	double b = c.getImaginary();
	if (a == 0.0 && b == 0.0) {
	    throw new IllegalArgumentException("Cannot divide by 0");
	}
	if (Math.abs(a) < Math.abs(b)) {
	    double q = a / b;
	    double denominator = a * q + b;
	    return new ComplexNumber((real * q + imaginary) / denominator,
		    (imaginary * q - real) / denominator);
	} else {
	    double q = b / a;
	    double denominator = b * q + a;
	    return new ComplexNumber((imaginary * q + real) / denominator,
		    (imaginary - real * q) / denominator);
	}
    }

    /**
     * 
     * @param n
     * @return
     */
    public ComplexNumber pow(int n) {
	return null;
    }

    /**
     * 
     * @param n
     * @return
     */
    public ComplexNumber[] root(int n) {
	double rootAngle = getAngle()/n;
	double rootMagnitude = Math.pow(getMagnitude(), 1./n);
	ComplexNumber[] roots = new ComplexNumber[n];
	for(int i = 0; i < n; i++){
		roots[i] = fromMagnitudeAndAngle(rootMagnitude, rootAngle);
		rootAngle += 2*Math.PI/n;
	}
	return roots;
    }

    /**
     * 
     */
    @Override
    public String toString() {
	if (imaginary == 0)
	    return real + "";
	if (real == 0)
	    return imaginary + "i";
	if (imaginary < 0)
	    return real + " - " + (-imaginary) + "i";
	return real + " + " + imaginary + "i";
    }

}
